<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Phase Fault Simulator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f3f4f6; /* text-gray-200 */
        }
        .control-panel {
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            margin-bottom: 1.5rem; /* mb-6 */
            border: 1px solid #374151; /* border-gray-700 */
        }
        .canvas-container {
            background-color: #1f2937; /* bg-gray-800 */
            border-radius: 0.75rem; /* rounded-xl */
            padding: 1.5rem; /* p-6 */
            border: 1px solid #374151; /* border-gray-700 */
        }
        canvas {
            background-color: #000;
            border-radius: 0.5rem; /* rounded-lg */
        }
        label {
            color: #d1d5db; /* text-gray-300 */
        }
        select, input[type="range"] {
            background-color: #374151; /* bg-gray-700 */
            border-color: #4b5563; /* border-gray-600 */
            color: #f3f4f6; /* text-gray-200 */
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-right: 1.5rem; /* mr-6 */
            font-size: 0.875rem; /* text-sm */
        }
        .legend-color {
            width: 1rem; /* w-4 */
            height: 1rem; /* h-4 */
            margin-right: 0.5rem; /* mr-2 */
            border-radius: 0.25rem; /* rounded-sm */
        }
    </style>
</head>
<body class="p-4 sm:p-6 lg:p-8">

    <div class="max-w-7xl mx-auto">
        <header class="text-center mb-6">
            <h1 class="text-3xl sm:text-4xl font-bold text-white">Three-Phase Fault Simulator</h1>
            <p class="text-lg text-gray-400 mt-2">Visualize voltage and current waveforms under different fault conditions.</p>
        </header>

        <!-- Layman's Explanation -->
        <div class="bg-gray-800 border border-gray-700 rounded-xl p-6 mb-6 text-gray-300">
            <h3 class="text-xl font-semibold text-white mb-2">What is an Electrical Fault? (A Simple Analogy)</h3>
            <p class="mb-2">Imagine the electrical grid is like a plumbing system for electricity. The wires are the pipes, and the electricity is the water flowing through them.</p>
            <ul class="list-disc list-inside space-y-1">
                <li><strong>Normal Operation:</strong> Water flows smoothly inside the pipes to where it's needed.</li>
                <li><strong>A Fault:</strong> This is like a sudden, major leak or a burst pipe. Instead of following its proper path, the electricity (water) rushes out uncontrollably, often towards the ground. This causes the pressure (voltage) to drop to zero at the leak point, while the flow rate (current) surges to a dangerous level.</li>
            </ul>
            <p class="mt-3">This simulator shows you what that sudden 'burst pipe' looks like on the graphs for different types of leaks (faults).</p>
        </div>

        <!-- Controls -->
        <div class="control-panel grid grid-cols-1 md:grid-cols-2 gap-6">
            <div>
                <label for="faultType" class="block mb-2 text-sm font-medium">Fault Type</label>
                <select id="faultType" class="w-full p-2.5 rounded-lg border focus:ring-blue-500 focus:border-blue-500">
                    <option value="normal">Normal Operation</option>
                    <option value="lg">Single Line-to-Ground (L-G on Phase A)</option>
                    <option value="ll">Line-to-Line (L-L on Phases A-B)</option>
                    <option value="llg">Double Line-to-Ground (LL-G on Phases A-B)</option>
                    <option value="lll">Symmetrical Three-Phase (LLL)</option>
                </select>
            </div>
            <div>
                <label for="faultInception" class="block mb-2 text-sm font-medium">Fault Inception Time (ms)</label>
                <div class="flex items-center">
                    <input id="faultInception" type="range" min="0" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    <span id="faultInceptionValue" class="ml-4 w-12 text-center">50 ms</span>
                </div>
            </div>
        </div>

        <!-- Voltage Waveform -->
        <div class="canvas-container mb-6">
            <h2 class="text-2xl font-semibold mb-4 text-white">Voltage Waveforms</h2>
            <canvas id="voltageCanvas"></canvas>
            <div id="voltageLegend" class="flex flex-wrap mt-4"></div>
        </div>

        <!-- Current Waveform -->
        <div class="canvas-container">
            <h2 class="text-2xl font-semibold mb-4 text-white">Current Waveforms</h2>
            <canvas id="currentCanvas"></canvas>
            <div id="currentLegend" class="flex flex-wrap mt-4"></div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- DOM Elements ---
        const faultTypeSelect = document.getElementById('faultType');
        const faultInceptionSlider = document.getElementById('faultInception');
        const faultInceptionValue = document.getElementById('faultInceptionValue');

        const voltageCanvas = document.getElementById('voltageCanvas');
        const vCtx = voltageCanvas.getContext('2d');
        const currentCanvas = document.getElementById('currentCanvas');
        const cCtx = currentCanvas.getContext('2d');

        // --- Simulation Parameters ---
        const V_PEAK = 13200;
        const I_PEAK = 438;
        const FREQUENCY = 50;
        const OMEGA = 2 * Math.PI * FREQUENCY;
        const TIME_SPAN = 0.1; // 100ms
        const POWER_FACTOR_ANGLE = -Math.PI / 6;

        const phases = [
            { name: 'A', color: '#ef4444' },
            { name: 'B', color: '#eab308' },
            { name: 'C', color: '#3b82f6' },
        ];

        let animationFrameId;
        let phaseShift = 0;

        // --- UI Setup ---
        faultInceptionSlider.addEventListener('input', (e) => {
            faultInceptionValue.textContent = `${e.target.value} ms`;
        });

        const createLegend = (containerId, prefix) => {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            phases.forEach(phase => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `<div class="legend-color" style="background-color: ${phase.color};"></div><span>${prefix}${phase.name}</span>`;
                container.appendChild(item);
            });
        };

        createLegend('voltageLegend', 'V');
        createLegend('currentLegend', 'I');

        // --- Canvas Sizing and Resizing ---
        function resizeCanvases() {
            const dpr = window.devicePixelRatio || 1;
            const containerWidth = voltageCanvas.parentElement.clientWidth - 48;
            
            [voltageCanvas, currentCanvas].forEach(canvas => {
                canvas.width = containerWidth * dpr;
                canvas.height = (containerWidth * 0.4) * dpr;
                canvas.style.width = `${containerWidth}px`;
                canvas.style.height = `${containerWidth * 0.4}px`;
                canvas.getContext('2d').scale(dpr, dpr);
            });
        }

        window.addEventListener('resize', resizeCanvases);
        
        // --- Core Drawing Logic ---
        function drawGrid(ctx, canvas, scale, unit) {
            const width = canvas.width / (window.devicePixelRatio || 1);
            const height = canvas.height / (window.devicePixelRatio || 1);
            
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 0.5;
            ctx.fillStyle = '#9ca3af';
            ctx.font = '12px Inter';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';

            for (let i = 0; i <= 20; i++) {
                const x = i * width / 20;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            const numYLines = 10;
            for (let i = 0; i <= numYLines; i++) {
                const y = i * height / numYLines;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
                const value = scale - (i * (2 * scale) / numYLines);
                const displayValue = Math.abs(value) >= 1000 ? `${(value/1000).toFixed(1)}k` : value.toFixed(0);
                ctx.fillText(`${displayValue}${unit}`, 5, y);
            }

            ctx.strokeStyle = '#6b7280';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
        }

        function calculateWaveforms(waveTime, graphTime, faultType, faultTriggerTime) {
            const isFaulted = graphTime >= faultTriggerTime;
            
            let va = V_PEAK * Math.sin(OMEGA * waveTime);
            let vb = V_PEAK * Math.sin(OMEGA * waveTime - 2 * Math.PI / 3);
            let vc = V_PEAK * Math.sin(OMEGA * waveTime + 2 * Math.PI / 3);

            let ia = I_PEAK * Math.sin(OMEGA * waveTime + POWER_FACTOR_ANGLE);
            let ib = I_PEAK * Math.sin(OMEGA * waveTime - 2 * Math.PI / 3 + POWER_FACTOR_ANGLE);
            let ic = I_PEAK * Math.sin(OMEGA * waveTime + 2 * Math.PI / 3 + POWER_FACTOR_ANGLE);

            if (isFaulted && faultType !== 'normal') {
                switch(faultType) {
                    case 'lg':
                        va = 0;
                        ia *= 5;
                        break;
                    case 'll':
                        va = vb = (V_PEAK * Math.sin(OMEGA * waveTime) + V_PEAK * Math.sin(OMEGA * waveTime - 2 * Math.PI / 3)) / 2;
                        ia *= 3;
                        ib = -ia;
                        ic = 0;
                        break;
                    case 'llg':
                        va = 0;
                        vb = 0;
                        ia *= 4;
                        ib *= 4;
                        break;
                    case 'lll':
                        va = 0;
                        vb = 0;
                        vc = 0;
                        ia *= 6;
                        ib *= 6;
                        ic *= 6;
                        break;
                }
            }
            return { voltages: { a: va, b: vb, c: vc }, currents: { a: ia, b: ib, c: ic } };
        }

        function draw(currentPhaseShift) {
            const faultType = faultTypeSelect.value;
            const faultInceptionTime = parseInt(faultInceptionSlider.value) / 1000;

            const canvases = [
                { ctx: vCtx, canvas: voltageCanvas, type: 'voltages', scale: V_PEAK * 1.1, unit: 'V' },
                { ctx: cCtx, canvas: currentCanvas, type: 'currents', scale: I_PEAK * 7, unit: 'A' }
            ];

            canvases.forEach(({ ctx, canvas, type, scale, unit }) => {
                const width = canvas.width / (window.devicePixelRatio || 1);
                const height = canvas.height / (window.devicePixelRatio || 1);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGrid(ctx, canvas, scale, unit);
                
                ctx.lineWidth = 2;

                for (let i = 0; i < phases.length; i++) {
                    const phase = phases[i];
                    ctx.strokeStyle = phase.color;
                    ctx.beginPath();
                    
                    for (let x = 0; x < width; x++) {
                        const graphTime = (x / width) * TIME_SPAN;
                        const waveTime = graphTime + currentPhaseShift;
                        
                        const waveforms = calculateWaveforms(waveTime, graphTime, faultType, faultInceptionTime);
                        const value = waveforms[type][phase.name.toLowerCase()];
                        const y = height / 2 - (value / scale) * (height / 2);
                        
                        if (x === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
            });
        }
        
        let lastTime = 0;
        function animate(timestamp) {
            if (!lastTime) {
                lastTime = timestamp;
            }
            const deltaTime = (timestamp - lastTime) / 1000; // time in seconds
            lastTime = timestamp;

            // The phase shift determines the speed of the wave scrolling
            const scrollSpeed = 0.5; // Adjust for faster/slower scroll
            phaseShift += deltaTime * scrollSpeed;

            // Use modulo to prevent phaseShift from growing infinitely large, which avoids floating point errors
            const period = 1 / FREQUENCY;
            phaseShift %= period;

            draw(phaseShift);
            animationFrameId = requestAnimationFrame(animate);
        }

        // --- Initial Call ---
        resizeCanvases();
        requestAnimationFrame(animate);
    });
    </script>
</body>
</html>
